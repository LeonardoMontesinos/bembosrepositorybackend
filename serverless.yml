org: bemmbos
service: bemmbos

plugins:
  - serverless-dotenv-plugin

provider:
  name: aws
  runtime: nodejs20.x
  region: us-east-1
  timeout: 29
  memorySize: 1024
  
  # --- CRÍTICO PARA AWS ACADEMY ---
  # Esto fuerza a usar el rol existente y evita que Serverless intente crear roles nuevos.
  iam:
    role: arn:aws:iam::131515946730:role/LabRole

  environment:
    # Tablas
    USER_TABLE: UserTable-${sls:stage}
    ORDERS_TABLE: OrdersTable-${sls:stage}
    MENU_TABLE: MenuTable-${sls:stage}
    KITCHEN_TABLE: KitchenTable-${sls:stage}
    WEBSOCKET_TABLE: WebSocketConnections-${sls:stage}
    
    # Buckets
    ORDERS_BUCKET: restaurant-orders-dashboard-${sls:stage}
    MENU_BUCKET: menu-bucket-${sls:stage}
    
    # Configuración General
    JWT_SECRET: 1234 # Cambiar por env var real en producción
    ALLOWED_ORIGINS: ${env:ALLOWED_ORIGINS, '*'}
    CORS_ALLOW_CREDENTIALS: ${env:CORS_ALLOW_CREDENTIALS, 'false'}
    WS_STAGE: ${sls:stage}
    
    # --- VARIABLES EVENT-DRIVEN ---
    # Usamos el bus 'default' porque Labs no deja crear buses custom
    EVENT_BUS_NAME: default
    WAITING_QUEUE_URL: { Ref: WaitingOrdersQueue }
    
    # Construcción dinámica del endpoint WebSocket para el Broadcaster
    WEBSOCKET_API_ENDPOINT: 
      Fn::Join:
        - ""
        - - "https://"
          - Ref: WebsocketsApi
          - ".execute-api."
          - ${self:provider.region}
          - ".amazonaws.com/${sls:stage}"

package:
  include:
    - scripts/**
    - utils/**
    - kitchen/**
    - websocket/**
  exclude:
    - openapi.json

custom: {}

functions:
  # ====================================================
  # AUTHENTICATION
  # ====================================================
  register:
    handler: auth/register.handler
    events:
      - http: { path: auth/register, method: post, cors: true }

  login:
    handler: auth/login.handler
    events:
      - http: { path: auth/login, method: post, cors: true }

  # ====================================================
  # AUTHORIZER (Tu código robusto)
  # ====================================================
  authorizer:
    handler: authorizer.handler
    # ¡IMPORTANTE! Pasamos explícitamente el secreto para evitar error 500
    environment:
      JWT_SECRET: ${self:provider.environment.JWT_SECRET}

  # ====================================================
  # ORDERS (Core + Eventos)
  # ====================================================
  
  # Crea el pedido y dispara evento 'OrderCreated' a EventBridge
  ordersCreate:
    handler: orders/index.create
    events:
      - http:
          path: orders
          method: post
          cors: true
          authorizer: &authConfig # Usamos ancla YAML para no repetir configuración
            name: authorizer
            type: request # Envía headers completos (necesario para tu código)
            identitySource: method.request.header.Authorization
            resultTtl: 0 # Sin caché para evitar errores durante desarrollo

  ordersList:
    handler: orders/index.list
    events:
      - http: { path: orders, method: get, cors: true, authorizer: *authConfig }

  ordersGet:
    handler: orders/index.get
    events:
      - http: { path: orders/{id}, method: get, cors: true, authorizer: *authConfig }

  # Actualiza estado y dispara 'KitchenSpaceAvailable' si se libera cocina
  ordersUpdateStatus:
    handler: orders/index.updateStatus
    events:
      - http: { path: orders/{id}/status, method: patch, cors: true, authorizer: *authConfig }

  # ====================================================
  # ADMIN & KITCHEN MANAGEMENT
  # ====================================================
  createKitchen:
    handler: kitchen/createKitchen.handler
    events:
      - http: { path: kitchens, method: post, cors: true, authorizer: *authConfig }

  listKitchens:
    handler: kitchen/listKitchens.handler
    events:
      - http: { path: kitchens, method: get, cors: true } # Público para el dashboard

  getMenu:
    handler: kitchen/getMenu.handler
    events:
      - http: { path: menu, method: get, cors: true } # Público

  adminCreateWorker:
    handler: admin/createWorker.handler
    events:
      - http: { path: admin/workers, method: post, cors: true, authorizer: *authConfig }

  adminCreateMenu:
    handler: admin/createMenu.handler
    events:
      - http: { path: admin/menu, method: post, cors: true, authorizer: *authConfig }

  adminUpdateMenu:
    handler: admin/updateMenu.handler
    events:
      - http: { path: admin/menu, method: patch, cors: true, authorizer: *authConfig }

  # ====================================================
  # EVENT DRIVEN BACKEND (Procesamiento Asíncrono)
  # ====================================================
  
  # 1. Router: Recibe 'OrderCreated' -> Decide si va a Cocina o SQS
  allocationManager:
    handler: kitchen/capacity.check
    events:
      - eventBridge:
          eventBus: default
          pattern:
            source: [ "bemmbos.orders" ]
            detail-type: [ "OrderCreated" ]

  # 2. Worker: Recibe 'KitchenSpaceAvailable' -> Saca de SQS -> Asigna
  queueWorker:
    handler: kitchen/capacity.processQueue
    events:
      - eventBridge:
          eventBus: default
          pattern:
            source: [ "bemmbos.kitchen" ]
            detail-type: [ "KitchenSpaceAvailable" ]

  # ====================================================
  # WEBSOCKETS (Real-time Dashboard)
  # ====================================================
  
  # Maneja conexión ($connect)
  wsConnect:
    handler: websocket/handler.connect
    events:
      - websocket:
          route: $connect
      - websocket:
          route: $disconnect

  # Notifica al frontend cuando ocurren eventos
  broadcaster:
    handler: websocket/handler.broadcast
    events:
      - eventBridge:
          eventBus: default
          pattern:
            source: [ "bemmbos.orders", "bemmbos.kitchen" ]

resources:
  Resources:
    # --------------------------------------------------
    # DynamoDB Tables
    # --------------------------------------------------
    UserTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.USER_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: userId, AttributeType: S }
          - { AttributeName: email, AttributeType: S }
          - { AttributeName: username, AttributeType: S }
          - { AttributeName: role, AttributeType: S }
        KeySchema:
          - { AttributeName: userId, KeyType: HASH }
          - { AttributeName: tenantId, KeyType: RANGE }
        GlobalSecondaryIndexes:
          - IndexName: EmailIndex
            KeySchema:
              - { AttributeName: email, KeyType: HASH }
              - { AttributeName: tenantId, KeyType: RANGE }
            Projection: { ProjectionType: ALL }
          - IndexName: UsernameIndex
            KeySchema:
              - { AttributeName: username, KeyType: HASH }
              - { AttributeName: tenantId, KeyType: RANGE }
            Projection: { ProjectionType: ALL }
          - IndexName: TenantRoleIndex
            KeySchema:
              - { AttributeName: tenantId, KeyType: HASH }
              - { AttributeName: role, KeyType: RANGE }
            Projection: { ProjectionType: ALL }

    OrdersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.ORDERS_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: PK, AttributeType: S }
          - { AttributeName: SK, AttributeType: S }
        KeySchema:
          - { AttributeName: PK, KeyType: HASH }
          - { AttributeName: SK, KeyType: RANGE }

    MenuTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.MENU_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: dishId, AttributeType: S }
        KeySchema:
          - { AttributeName: tenantId, KeyType: HASH }
          - { AttributeName: dishId, KeyType: RANGE }

    KitchenTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.KITCHEN_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: kitchenId, AttributeType: S }
        KeySchema:
          - { AttributeName: tenantId, KeyType: HASH }
          - { AttributeName: kitchenId, KeyType: RANGE }

    WebSocketConnectionsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.WEBSOCKET_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: connectionId, AttributeType: S }
        KeySchema:
          - { AttributeName: tenantId, KeyType: HASH }
          - { AttributeName: connectionId, KeyType: RANGE }

    # --------------------------------------------------
    # S3 Buckets
    # --------------------------------------------------
    OrdersBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:provider.environment.ORDERS_BUCKET}

    MenuBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:provider.environment.MENU_BUCKET}

    # --------------------------------------------------
    # SQS Queue
    # --------------------------------------------------
    WaitingOrdersQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: waiting-orders-queue-${sls:stage}
