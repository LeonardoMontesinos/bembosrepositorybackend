org: luciajcm
service: bemmbos

plugins:
  - serverless-dotenv-plugin
  - serverless-step-functions

provider:
  name: aws
  runtime: nodejs20.x
  region: us-east-1
  timeout: 29
  memorySize: 1024
  # Uso de AccountID din치mico para portabilidad en laboratorios
  iam:
    role: arn:aws:iam::${aws:accountId}:role/LabRole

  environment:
    # --- TABLAS DYNAMODB ---
    USER_TABLE: UserTable-${sls:stage}
    ORDERS_TABLE: OrdersTable-${sls:stage}
    MENU_TABLE: MenuTable-${sls:stage}
    KITCHEN_TABLE: KitchenTable-${sls:stage}
    KITCHEN_STATE_TABLE: KitchenStateTable-${sls:stage}
    AUDIT_TABLE: AuditTable-${sls:stage}
    CONNECTIONS_TABLE: ConnectionsTable-${sls:stage}
    
    # --- BUCKETS S3 ---
    ORDERS_BUCKET: restaurant-orders-dashboard-${sls:stage}-${aws:accountId}
    MENU_BUCKET: menu-bucket-${sls:stage}-${aws:accountId}
    
    # --- CONFIGURACI칍N ---
    JWT_SECRET: ${env:JWT_SECRET, '1234'}
    ALLOWED_ORIGINS: ${env:ALLOWED_ORIGINS, '*'}
    CORS_ALLOW_CREDENTIALS: ${env:CORS_ALLOW_CREDENTIALS, 'false'}
    SLS_STAGE: ${sls:stage}
    
    # --- INFRAESTRUCTURA DE EVENTOS ---
    INGESTION_BUS: IngestionBus-${sls:stage}
    NOTIFICATION_BUS: NotificationBus-${sls:stage}
    WAITING_QUEUE_URL: { Ref: WaitingOrdersQueue }
    OPERATIONS_TOPIC_ARN: { Ref: OperationsAlertTopic }
    CUSTOMER_TOPIC_ARN: { Ref: CustomerNotificationTopic }
    
    # --- ARN STEP FUNCTION (Manual para evitar dep. circular) ---
    STATE_MACHINE_ARN: 
      Fn::Join:
        - ":"
        - - "arn:aws:states"
          - Ref: "AWS::Region"
          - Ref: "AWS::AccountId"
          - "stateMachine"
          - "KitchenWorkflow-${sls:stage}"

package:
  patterns:
    - '!node_modules/aws-sdk/**' # Excluir SDK si usas runtime node18/20
    - '!tests/**'
    - '!docs/**'

functions:
  # ===================================================
  # 1. AUTH
  # ===================================================
  register:
    handler: auth/register.handler
    events:
      - http: { path: auth/register, method: post, cors: true }
    environment:
      CUSTOMER_TOPIC_ARN: { Ref: CustomerNotificationTopic }
  
  login:
    handler: auth/login.handler
    events:
      - http: { path: auth/login, method: post, cors: true }
  
  authorizer:
    handler: authorizer.handler

  # ===================================================
  # 2. ADMIN & KITCHEN CRUD
  # ===================================================
  adminCreateWorker:
    handler: admin/createWorker.handler
    events:
      - http: { path: admin/workers, method: post, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }
  
  adminCreateMenu:
    handler: admin/createMenu.handler
    events:
      - http: { path: admin/menu, method: post, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }
  
  adminUpdateMenu:
    handler: admin/updateMenu.handler
    events:
      - http: { path: admin/menu, method: patch, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }

  createKitchen:
    handler: kitchen/createKitchen.handler
    events:
      - http: { path: kitchens, method: post, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }
  
  listKitchens:
    handler: kitchen/listKitchens.handler
    events:
      - http: { path: kitchens, method: get, cors: true }
  
  getMenu:
    handler: kitchen/getMenu.handler
    events:
      - http: { path: menu, method: get, cors: true }

  # ===================================================
  # 3. ORDERS API
  # ===================================================
  ordersCreate:
    handler: orders/create.handler
    events:
      - http: { path: orders, method: post, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }
  
  # LISTA INTELIGENTE (Detecta rol Admin vs User)
  ordersList:
    handler: orders/list.handler 
    events:
      - http: { path: orders, method: get, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }
  
  ordersGet:
    handler: orders/get.handler
    events:
      - http: { path: orders/{id}, method: get, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }
  
  ordersUpdateStatus:
    handler: orders/updateStatus.handler
    events:
      - http: { path: orders/{id}/status, method: patch, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }

  # HISTORIAL DE AUDITOR칈A (GET)
  getOrderHistory:
    handler: orders/history.handler
    events:
      - http: { path: orders/{id}/history, method: get, cors: true, authorizer: { name: authorizer, type: request, identitySource: method.request.header.Authorization } }

  # ===================================================
  # 4. WEBSOCKETS (REAL-TIME)
  # ===================================================
  
  # Conexi칩n ($connect / $disconnect)
  wsConnectionHandler:
    handler: websocket/connectionManager.handler
    events:
      - websocket:
          route: $connect
          authorizer:
            name: authorizer
            # Le decimos a AWS que busque el token en la query string
            identitySource:
              - 'route.request.querystring.token'
      - websocket:
          route: $disconnect

  # Broadcaster: Lee Stream y notifica al socket
  wsBroadcaster:
    handler: websocket/broadcaster.handler
    environment:
      # Construcci칩n din치mica del endpoint de callback para WS
      WEBSOCKET_API_ENDPOINT:
        Fn::Join:
          - ""
          - - "https://"
            - Ref: WebsocketsApi
            - ".execute-api."
            - Ref: AWS::Region
            - ".amazonaws.com/${sls:stage}"
    events:
      - stream:
          type: dynamodb
          arn:
            Fn::GetAtt: [OrdersTable, StreamArn]
          batchSize: 1

  # ===================================================
  # 5. BACKEND PROCESSES & WORKFLOW
  # ===================================================
  
  # Auditor칤a: Guarda logs en AuditTable (Stream)
  auditLogger:
    handler: audit/logger.handler
    events:
      - stream:
          type: dynamodb
          arn:
            Fn::GetAtt: [OrdersTable, StreamArn]
          batchSize: 1
          startingPosition: LATEST

  # Capacity Checker (EventBridge Entry)
  capacityChecker:
    handler: capacity/checker.handler
    events:
      - eventBridge:
          eventBus: { Ref: IngestionBus }
          pattern:
            source: ['bembos.orders']
            detail-type: ['OrderCreated']

  kitchenSpaceManager:
    handler: capacity/manager.handler

  dequeueOrder:
    handler: capacity/dequeue.handler

  # Workflow Tasks (Conexi칩n Real a BD)
  sfPrepare:
    handler: workflow/prepare.handler
    environment: { ORDERS_TABLE: { Ref: OrdersTable } }

  sfAssignCook:
    handler: workflow/assignCook.handler
    environment: 
      ORDERS_TABLE: { Ref: OrdersTable } 
      USER_TABLE: { Ref: UserTable }

  sfCookProcess:
    handler: workflow/cook.handler
    environment: { ORDERS_TABLE: { Ref: OrdersTable } }

  sfDispatch:
    handler: workflow/dispatch.handler
    environment:
      ORDERS_TABLE: { Ref: OrdersTable }
      NOTIFICATION_BUS: { Ref: NotificationBus }

  notifyCustomer:
    handler: notifications/emailCustomer.handler
    events:
      - eventBridge:
          eventBus: { Ref: NotificationBus }
          pattern:
            source: ['bembos.kitchen']
            detail-type: ['OrderReady']

# ===================================================
# DEFINICI칍N DE STEP FUNCTION
# ===================================================
stepFunctions:
  stateMachines:
    KitchenWorkflow:
      name: KitchenWorkflow-${sls:stage}
      role: arn:aws:iam::${aws:accountId}:role/LabRole
      definition:
        Comment: "Flujo Inteligente de Cocina"
        StartAt: PrepareData
        States:
          PrepareData:
            Type: Task
            Resource: !GetAtt sfPrepare.Arn
            Next: AssignCook
          AssignCook:
            Type: Task
            Resource: !GetAtt sfAssignCook.Arn
            Next: CookingPhase
          CookingPhase:
            Type: Task
            Resource: !GetAtt sfCookProcess.Arn
            Next: CookingWait
          CookingWait:
            Type: Wait
            Seconds: 60 # Espera simulada de cocci칩n
            Next: CheckOrderType
          CheckOrderType:
            Type: Choice
            Choices:
              - Variable: "$.type"
                StringEquals: "DELIVERY"
                Next: ProcessDelivery
            Default: ProcessPickup
          ProcessDelivery:
            Type: Pass
            Parameters:
              status: "SENDED"
              msg: "Tu repartidor va en camino 游띳"
            ResultPath: "$.dispatchInfo"
            Next: FinalizeOrder
          ProcessPickup:
            Type: Pass
            Parameters:
              status: "READY_PICKUP"
              msg: "Listo para recoger en mostrador 游꼢"
            ResultPath: "$.dispatchInfo"
            Next: FinalizeOrder
          FinalizeOrder:
            Type: Task
            Resource: !GetAtt sfDispatch.Arn
            Next: ReleaseCapacity
          ReleaseCapacity:
            Type: Task
            Resource: !GetAtt kitchenSpaceManager.Arn
            End: true

# ===================================================
# RECURSOS (CloudFormation)
# ===================================================
resources:
  Resources:
    # --- DYNAMODB TABLES ---
    UserTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.USER_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: userId, AttributeType: S }
          - { AttributeName: email, AttributeType: S }
          - { AttributeName: username, AttributeType: S }
          - { AttributeName: role, AttributeType: S }
        KeySchema:
          - { AttributeName: userId, KeyType: HASH }
          - { AttributeName: tenantId, KeyType: RANGE }
        GlobalSecondaryIndexes:
          - IndexName: EmailIndex
            KeySchema: [{ AttributeName: email, KeyType: HASH }, { AttributeName: tenantId, KeyType: RANGE }]
            Projection: { ProjectionType: ALL }
          - IndexName: UsernameIndex
            KeySchema: [{ AttributeName: username, KeyType: HASH }, { AttributeName: tenantId, KeyType: RANGE }]
            Projection: { ProjectionType: ALL }
          - IndexName: TenantRoleIndex
            KeySchema: [{ AttributeName: tenantId, KeyType: HASH }, { AttributeName: role, KeyType: RANGE }]
            Projection: { ProjectionType: ALL }

    OrdersTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.ORDERS_TABLE}
        BillingMode: PAY_PER_REQUEST
        # Habilitar STREAMS para Auditor칤a y WebSockets
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
        AttributeDefinitions:
          - { AttributeName: PK, AttributeType: S }
          - { AttributeName: SK, AttributeType: S }
        KeySchema:
          - { AttributeName: PK, KeyType: HASH }
          - { AttributeName: SK, KeyType: RANGE }

    AuditTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.AUDIT_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: PK, AttributeType: S }
          - { AttributeName: SK, AttributeType: S }
        KeySchema:
          - { AttributeName: PK, KeyType: HASH }
          - { AttributeName: SK, KeyType: RANGE }

    ConnectionsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.CONNECTIONS_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: connectionId, AttributeType: S }
          - { AttributeName: userId, AttributeType: S }
        KeySchema:
          - { AttributeName: connectionId, KeyType: HASH }
        GlobalSecondaryIndexes:
          - IndexName: UserIndex
            KeySchema: [{ AttributeName: userId, KeyType: HASH }]
            Projection: { ProjectionType: ALL }

    MenuTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.MENU_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: dishId, AttributeType: S }
        KeySchema:
          - { AttributeName: tenantId, KeyType: HASH }
          - { AttributeName: dishId, KeyType: RANGE }

    KitchenTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.KITCHEN_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: tenantId, AttributeType: S }
          - { AttributeName: kitchenId, AttributeType: S }
        KeySchema:
          - { AttributeName: tenantId, KeyType: HASH }
          - { AttributeName: kitchenId, KeyType: RANGE }

    KitchenStateTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.KITCHEN_STATE_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - { AttributeName: kitchenId, AttributeType: S }
        KeySchema:
          - { AttributeName: kitchenId, KeyType: HASH }

    # --- S3 BUCKETS ---
    OrdersBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:provider.environment.ORDERS_BUCKET}

    MenuBucket:
      Type: AWS::S3::Bucket
      Properties:
        BucketName: ${self:provider.environment.MENU_BUCKET}
        # Configuraci칩n para permitir im치genes p칰blicas
        PublicAccessBlockConfiguration:
          BlockPublicAcls: false
          IgnorePublicAcls: false
          BlockPublicPolicy: false
          RestrictPublicBuckets: false
        OwnershipControls:
          Rules:
            - ObjectOwnership: BucketOwnerPreferred

    # --- EVENT BUSES & MESSAGING ---
    IngestionBus:
      Type: AWS::Events::EventBus
      Properties:
        Name: ${self:provider.environment.INGESTION_BUS}

    NotificationBus:
      Type: AWS::Events::EventBus
      Properties:
        Name: ${self:provider.environment.NOTIFICATION_BUS}

    WaitingOrdersQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: WaitingOrdersQueue-${sls:stage}
        MessageRetentionPeriod: 86400

    OperationsAlertTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: OperationsAlertTopic-${sls:stage}

    CustomerNotificationTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: CustomerNotificationTopic-${sls:stage}
